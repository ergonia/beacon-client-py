{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About A Python client for interacting with the Ethereum Beacon Chain API Beacon Chain API Reference Ethereum Consensus Specification Ethereum Consensus Specification Annotated This implementation also leans on types implemented here Simple Example from beacon_client.api import BeaconChainAPI client = BeaconChainAPI(\"http://localhost:5052\") client.get_headers_from_block_id(block_id=\"head\") Streaming Example for event in client.stream_events(head=True, block=True, attestation=True): match event.event: case \"head\": print(client.parse_head(event.data)) case \"block\": print(client.parse_block(event.data)) case \"attestation\": print(client.parse_attestation(event.data)) case other: pass","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about","text":"A Python client for interacting with the Ethereum Beacon Chain API Beacon Chain API Reference Ethereum Consensus Specification Ethereum Consensus Specification Annotated This implementation also leans on types implemented here","title":"About"},{"location":"#simple-example","text":"from beacon_client.api import BeaconChainAPI client = BeaconChainAPI(\"http://localhost:5052\") client.get_headers_from_block_id(block_id=\"head\")","title":"Simple Example"},{"location":"#streaming-example","text":"for event in client.stream_events(head=True, block=True, attestation=True): match event.event: case \"head\": print(client.parse_head(event.data)) case \"block\": print(client.parse_block(event.data)) case \"attestation\": print(client.parse_attestation(event.data)) case other: pass","title":"Streaming Example"},{"location":"beacon_endpoints/","text":"Beacon Endpoints beacon_client.beacon_endpoints.BeaconEndpoints Source code in beacon_client/beacon_endpoints.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class BeaconEndpoints : def get_genesis ( self ) -> GenesisDetails : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" value = self . _query_url ( \"/eth/v1/beacon/genesis\" ) data = parse_json ( value [ \"data\" ], GenesisDetails ) return data def get_state_root ( self , state_id : StateId ) -> Root : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) data = Root ( value [ \"data\" ][ \"root\" ]) return data def get_fork_from_state ( self , state_id : StateId ) -> Fork : \"\"\" Returns Fork object for state with given 'state_id'. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) data = parse_json ( value [ \"data\" ], Fork ) return data def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> FinalityCheckpoints : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) data = parse_json ( value [ \"data\" ], FinalityCheckpoints ) return data def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> List [ ValidatorSummary ]: \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index pending_initialized: If true return validators with this status pending_queued: If true return validators with this status active_ongoing: If true return validators with this status active_exiting: If true return validators with this status active_slashed: If true return validators with this status exited_unslashed: If true return validators with this status exited_slashed: If true return validators with this status withdrawal_possible: If true return validators with this status withdrawal_done: If true return validators with this status active: If true return validators with this status pending: If true return validators with this status exited: If true return validators with this status withdrawal: If true return validators with this status \"\"\" status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data def get_validators_from_state_by_id ( self , state_id : StateId , validator_id : ValidatorId ) -> ValidatorSummary : \"\"\" Returns validator specified by state and id or public key along with status and balance. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_id: Validator identified by public key or validator index \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None ) -> List [ BalanceSummary ]: \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index \"\"\" params = { \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) data = parse_json ( value [ \"data\" ], BalanceSummary ) return data def get_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None , index : Union [ ValidatorIndex , None ] = None , slot : Union [ Slot , None ] = None , ) -> List [ CommitteeSummary ]: \"\"\" Retrieves the committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained index: Restrict returned values to those matching the supplied committee index slot: Restrict returned values to those matching the supplied slot \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) data = parse_json ( value [ \"data\" ], CommitteeSummary ) return data def get_sync_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None ) -> SyncCommitteeSummary : \"\"\" Retrieves the sync committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained \"\"\" params = { \"epoch\" : epoch , } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) data = parse_json ( value [ \"data\" ], SyncCommitteeSummary ) return data def get_headers ( self , slot : Union [ Slot , None ] = None , parent_root : Union [ Root , None ] = None ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: slot: Restrict returned values to those matching the supplied slot parent_root: Restrict returned values to those matching the supplied parent_root \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } value = self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data def get_headers_from_block_id ( self , block_id : BlockId ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: block_id: Return block header matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data def get_block_from_block_id ( self , block_id : BlockId , response_type : str = \"json\" ) -> Union [ SignedBeaconBlock , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Args: block_id: Return block matching given block id response_type: Element of [json, szz] that determines the return type \"\"\" match response_type : case \"json\" : headers = { \"Accept\" : \"application/json\" } value = self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) data = parse_json ( value [ \"data\" ], SignedBeaconBlock ) return data case \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) case other : assert Exception ( \"response_type must be in [json, ssz]\" ) def get_block_root_from_block_id ( self , block_id : BlockId ) -> Root : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Args: block_id: Return block root matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) return Root ( value [ \"data\" ][ \"root\" ]) def get_attestations_from_block_id ( self , block_id : BlockId ) -> List [ Attestation ]: \"\"\" Retrieves attestation included in requested block. Args: block_id: Return attestations matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) data = parse_json ( value [ \"data\" ], Attestation ) return data def get_pool_attestations ( self , slot : Union [ Slot , None ] = None , committee_index : Union [ CommitteeIndex , None ] = None , ) -> List [ Attestation ]: \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block Args: slot: Restrict returned values to those matching the supplied slot committee_index: Restrict returned values to those matching the supplied committee index \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } value = self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) data = parse_json ( value [ \"data\" ], Attestation ) return data def get_pool_attester_slashings ( self ) -> list : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] def get_pool_proposer_slashings ( self ) -> list : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] get_attestations_from_block_id ( block_id ) Retrieves attestation included in requested block. Parameters: Name Type Description Default block_id BlockId Return attestations matching given block id required Source code in beacon_client/beacon_endpoints.py 291 292 293 294 295 296 297 298 299 def get_attestations_from_block_id ( self , block_id : BlockId ) -> List [ Attestation ]: \"\"\" Retrieves attestation included in requested block. Args: block_id: Return attestations matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) data = parse_json ( value [ \"data\" ], Attestation ) return data get_block_from_block_id ( block_id , response_type = 'json' ) Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Parameters: Name Type Description Default block_id BlockId Return block matching given block id required response_type str Element of [json, szz] that determines the return type 'json' Source code in beacon_client/beacon_endpoints.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def get_block_from_block_id ( self , block_id : BlockId , response_type : str = \"json\" ) -> Union [ SignedBeaconBlock , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Args: block_id: Return block matching given block id response_type: Element of [json, szz] that determines the return type \"\"\" match response_type : case \"json\" : headers = { \"Accept\" : \"application/json\" } value = self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) data = parse_json ( value [ \"data\" ], SignedBeaconBlock ) return data case \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) case other : assert Exception ( \"response_type must be in [json, ssz]\" ) get_block_root_from_block_id ( block_id ) Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Parameters: Name Type Description Default block_id BlockId Return block root matching given block id required Source code in beacon_client/beacon_endpoints.py 282 283 284 285 286 287 288 289 def get_block_root_from_block_id ( self , block_id : BlockId ) -> Root : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Args: block_id: Return block root matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) return Root ( value [ \"data\" ][ \"root\" ]) get_committees_from_state ( state_id , epoch = None , index = None , slot = None ) Retrieves the committees for the given state. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required epoch Union [ Epoch , None] Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained None index Union [ ValidatorIndex , None] Restrict returned values to those matching the supplied committee index None slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None Source code in beacon_client/beacon_endpoints.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def get_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None , index : Union [ ValidatorIndex , None ] = None , slot : Union [ Slot , None ] = None , ) -> List [ CommitteeSummary ]: \"\"\" Retrieves the committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained index: Restrict returned values to those matching the supplied committee index slot: Restrict returned values to those matching the supplied slot \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) data = parse_json ( value [ \"data\" ], CommitteeSummary ) return data get_finality_checkpoints_from_state ( state_id ) Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> FinalityCheckpoints : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) data = parse_json ( value [ \"data\" ], FinalityCheckpoints ) return data get_fork_from_state ( state_id ) Returns Fork object for state with given 'state_id'. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 51 52 53 54 55 56 57 58 59 def get_fork_from_state ( self , state_id : StateId ) -> Fork : \"\"\" Returns Fork object for state with given 'state_id'. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) data = parse_json ( value [ \"data\" ], Fork ) return data get_genesis () Retrieve details of the chain's genesis which can be used to identify chain. Source code in beacon_client/beacon_endpoints.py 32 33 34 35 36 37 38 def get_genesis ( self ) -> GenesisDetails : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" value = self . _query_url ( \"/eth/v1/beacon/genesis\" ) data = parse_json ( value [ \"data\" ], GenesisDetails ) return data get_headers ( slot = None , parent_root = None ) Retrieves block headers matching given query. By default it will fetch current head slot blocks. Parameters: Name Type Description Default slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None parent_root Union [ Root , None] Restrict returned values to those matching the supplied parent_root None Source code in beacon_client/beacon_endpoints.py 231 232 233 234 235 236 237 238 239 240 241 242 243 def get_headers ( self , slot : Union [ Slot , None ] = None , parent_root : Union [ Root , None ] = None ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: slot: Restrict returned values to those matching the supplied slot parent_root: Restrict returned values to those matching the supplied parent_root \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } value = self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data get_headers_from_block_id ( block_id ) Retrieves block headers matching given query. By default it will fetch current head slot blocks. Parameters: Name Type Description Default block_id BlockId Return block header matching given block id required Source code in beacon_client/beacon_endpoints.py 245 246 247 248 249 250 251 252 253 def get_headers_from_block_id ( self , block_id : BlockId ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: block_id: Return block header matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data get_pool_attestations ( slot = None , committee_index = None ) Retrieves attestations known by the node but not necessarily incorporated into any block Parameters: Name Type Description Default slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None committee_index Union [ CommitteeIndex , None] Restrict returned values to those matching the supplied committee index None Source code in beacon_client/beacon_endpoints.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def get_pool_attestations ( self , slot : Union [ Slot , None ] = None , committee_index : Union [ CommitteeIndex , None ] = None , ) -> List [ Attestation ]: \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block Args: slot: Restrict returned values to those matching the supplied slot committee_index: Restrict returned values to those matching the supplied committee index \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } value = self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) data = parse_json ( value [ \"data\" ], Attestation ) return data get_pool_attester_slashings () Retrieves attester slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 317 318 319 320 321 322 323 def get_pool_attester_slashings ( self ) -> list : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] get_pool_proposer_slashings () Retrieves proposer slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 325 326 327 328 329 330 331 def get_pool_proposer_slashings ( self ) -> list : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] get_pool_voluntary_exits () Retrieves voluntary exits known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 333 334 335 336 337 338 339 def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] get_state_root ( state_id ) Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 40 41 42 43 44 45 46 47 48 49 def get_state_root ( self , state_id : StateId ) -> Root : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) data = Root ( value [ \"data\" ][ \"root\" ]) return data get_sync_committees_from_state ( state_id , epoch = None ) Retrieves the sync committees for the given state. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required epoch Union [ Epoch , None] Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained None Source code in beacon_client/beacon_endpoints.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def get_sync_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None ) -> SyncCommitteeSummary : \"\"\" Retrieves the sync committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained \"\"\" params = { \"epoch\" : epoch , } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) data = parse_json ( value [ \"data\" ], SyncCommitteeSummary ) return data get_validators_balances_from_state ( state_id , validator_list = None ) Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_list Union [ List [ ValidatorId ], None] List of validators identified by public key or validator index None Source code in beacon_client/beacon_endpoints.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None ) -> List [ BalanceSummary ]: \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index \"\"\" params = { \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) data = parse_json ( value [ \"data\" ], BalanceSummary ) return data get_validators_from_state ( state_id , validator_list = None , pending_initialized = False , pending_queued = False , active_ongoing = False , active_exiting = False , active_slashed = False , exited_unslashed = False , exited_slashed = False , withdrawal_possible = False , withdrawal_done = False , active = False , pending = False , exited = False , withdrawal = False ) Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_list Union [ List [ ValidatorId ], None] List of validators identified by public key or validator index None pending_initialized bool If true return validators with this status False pending_queued bool If true return validators with this status False active_ongoing bool If true return validators with this status False active_exiting bool If true return validators with this status False active_slashed bool If true return validators with this status False exited_unslashed bool If true return validators with this status False exited_slashed bool If true return validators with this status False withdrawal_possible bool If true return validators with this status False withdrawal_done bool If true return validators with this status False active bool If true return validators with this status False pending bool If true return validators with this status False exited bool If true return validators with this status False withdrawal bool If true return validators with this status False Source code in beacon_client/beacon_endpoints.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> List [ ValidatorSummary ]: \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index pending_initialized: If true return validators with this status pending_queued: If true return validators with this status active_ongoing: If true return validators with this status active_exiting: If true return validators with this status active_slashed: If true return validators with this status exited_unslashed: If true return validators with this status exited_slashed: If true return validators with this status withdrawal_possible: If true return validators with this status withdrawal_done: If true return validators with this status active: If true return validators with this status pending: If true return validators with this status exited: If true return validators with this status withdrawal: If true return validators with this status \"\"\" status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data get_validators_from_state_by_id ( state_id , validator_id ) Returns validator specified by state and id or public key along with status and balance. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_id ValidatorId Validator identified by public key or validator index required Source code in beacon_client/beacon_endpoints.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def get_validators_from_state_by_id ( self , state_id : StateId , validator_id : ValidatorId ) -> ValidatorSummary : \"\"\" Returns validator specified by state and id or public key along with status and balance. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_id: Validator identified by public key or validator index \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data","title":"Beacon Endpoints"},{"location":"beacon_endpoints/#beacon-endpoints","text":"","title":"Beacon Endpoints"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints","text":"Source code in beacon_client/beacon_endpoints.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 class BeaconEndpoints : def get_genesis ( self ) -> GenesisDetails : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" value = self . _query_url ( \"/eth/v1/beacon/genesis\" ) data = parse_json ( value [ \"data\" ], GenesisDetails ) return data def get_state_root ( self , state_id : StateId ) -> Root : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) data = Root ( value [ \"data\" ][ \"root\" ]) return data def get_fork_from_state ( self , state_id : StateId ) -> Fork : \"\"\" Returns Fork object for state with given 'state_id'. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) data = parse_json ( value [ \"data\" ], Fork ) return data def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> FinalityCheckpoints : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) data = parse_json ( value [ \"data\" ], FinalityCheckpoints ) return data def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> List [ ValidatorSummary ]: \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index pending_initialized: If true return validators with this status pending_queued: If true return validators with this status active_ongoing: If true return validators with this status active_exiting: If true return validators with this status active_slashed: If true return validators with this status exited_unslashed: If true return validators with this status exited_slashed: If true return validators with this status withdrawal_possible: If true return validators with this status withdrawal_done: If true return validators with this status active: If true return validators with this status pending: If true return validators with this status exited: If true return validators with this status withdrawal: If true return validators with this status \"\"\" status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data def get_validators_from_state_by_id ( self , state_id : StateId , validator_id : ValidatorId ) -> ValidatorSummary : \"\"\" Returns validator specified by state and id or public key along with status and balance. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_id: Validator identified by public key or validator index \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None ) -> List [ BalanceSummary ]: \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index \"\"\" params = { \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) data = parse_json ( value [ \"data\" ], BalanceSummary ) return data def get_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None , index : Union [ ValidatorIndex , None ] = None , slot : Union [ Slot , None ] = None , ) -> List [ CommitteeSummary ]: \"\"\" Retrieves the committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained index: Restrict returned values to those matching the supplied committee index slot: Restrict returned values to those matching the supplied slot \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) data = parse_json ( value [ \"data\" ], CommitteeSummary ) return data def get_sync_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None ) -> SyncCommitteeSummary : \"\"\" Retrieves the sync committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained \"\"\" params = { \"epoch\" : epoch , } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) data = parse_json ( value [ \"data\" ], SyncCommitteeSummary ) return data def get_headers ( self , slot : Union [ Slot , None ] = None , parent_root : Union [ Root , None ] = None ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: slot: Restrict returned values to those matching the supplied slot parent_root: Restrict returned values to those matching the supplied parent_root \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } value = self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data def get_headers_from_block_id ( self , block_id : BlockId ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: block_id: Return block header matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data def get_block_from_block_id ( self , block_id : BlockId , response_type : str = \"json\" ) -> Union [ SignedBeaconBlock , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Args: block_id: Return block matching given block id response_type: Element of [json, szz] that determines the return type \"\"\" match response_type : case \"json\" : headers = { \"Accept\" : \"application/json\" } value = self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) data = parse_json ( value [ \"data\" ], SignedBeaconBlock ) return data case \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) case other : assert Exception ( \"response_type must be in [json, ssz]\" ) def get_block_root_from_block_id ( self , block_id : BlockId ) -> Root : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Args: block_id: Return block root matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) return Root ( value [ \"data\" ][ \"root\" ]) def get_attestations_from_block_id ( self , block_id : BlockId ) -> List [ Attestation ]: \"\"\" Retrieves attestation included in requested block. Args: block_id: Return attestations matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) data = parse_json ( value [ \"data\" ], Attestation ) return data def get_pool_attestations ( self , slot : Union [ Slot , None ] = None , committee_index : Union [ CommitteeIndex , None ] = None , ) -> List [ Attestation ]: \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block Args: slot: Restrict returned values to those matching the supplied slot committee_index: Restrict returned values to those matching the supplied committee index \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } value = self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) data = parse_json ( value [ \"data\" ], Attestation ) return data def get_pool_attester_slashings ( self ) -> list : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] def get_pool_proposer_slashings ( self ) -> list : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ] def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ]","title":"BeaconEndpoints"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_attestations_from_block_id","text":"Retrieves attestation included in requested block. Parameters: Name Type Description Default block_id BlockId Return attestations matching given block id required Source code in beacon_client/beacon_endpoints.py 291 292 293 294 295 296 297 298 299 def get_attestations_from_block_id ( self , block_id : BlockId ) -> List [ Attestation ]: \"\"\" Retrieves attestation included in requested block. Args: block_id: Return attestations matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) data = parse_json ( value [ \"data\" ], Attestation ) return data","title":"get_attestations_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_block_from_block_id","text":"Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Parameters: Name Type Description Default block_id BlockId Return block matching given block id required response_type str Element of [json, szz] that determines the return type 'json' Source code in beacon_client/beacon_endpoints.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def get_block_from_block_id ( self , block_id : BlockId , response_type : str = \"json\" ) -> Union [ SignedBeaconBlock , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Args: block_id: Return block matching given block id response_type: Element of [json, szz] that determines the return type \"\"\" match response_type : case \"json\" : headers = { \"Accept\" : \"application/json\" } value = self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) data = parse_json ( value [ \"data\" ], SignedBeaconBlock ) return data case \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) case other : assert Exception ( \"response_type must be in [json, ssz]\" )","title":"get_block_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_block_root_from_block_id","text":"Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Parameters: Name Type Description Default block_id BlockId Return block root matching given block id required Source code in beacon_client/beacon_endpoints.py 282 283 284 285 286 287 288 289 def get_block_root_from_block_id ( self , block_id : BlockId ) -> Root : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Args: block_id: Return block root matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) return Root ( value [ \"data\" ][ \"root\" ])","title":"get_block_root_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_committees_from_state","text":"Retrieves the committees for the given state. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required epoch Union [ Epoch , None] Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained None index Union [ ValidatorIndex , None] Restrict returned values to those matching the supplied committee index None slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None Source code in beacon_client/beacon_endpoints.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def get_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None , index : Union [ ValidatorIndex , None ] = None , slot : Union [ Slot , None ] = None , ) -> List [ CommitteeSummary ]: \"\"\" Retrieves the committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained index: Restrict returned values to those matching the supplied committee index slot: Restrict returned values to those matching the supplied slot \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) data = parse_json ( value [ \"data\" ], CommitteeSummary ) return data","title":"get_committees_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_finality_checkpoints_from_state","text":"Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> FinalityCheckpoints : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) data = parse_json ( value [ \"data\" ], FinalityCheckpoints ) return data","title":"get_finality_checkpoints_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_fork_from_state","text":"Returns Fork object for state with given 'state_id'. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 51 52 53 54 55 56 57 58 59 def get_fork_from_state ( self , state_id : StateId ) -> Fork : \"\"\" Returns Fork object for state with given 'state_id'. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) data = parse_json ( value [ \"data\" ], Fork ) return data","title":"get_fork_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_genesis","text":"Retrieve details of the chain's genesis which can be used to identify chain. Source code in beacon_client/beacon_endpoints.py 32 33 34 35 36 37 38 def get_genesis ( self ) -> GenesisDetails : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" value = self . _query_url ( \"/eth/v1/beacon/genesis\" ) data = parse_json ( value [ \"data\" ], GenesisDetails ) return data","title":"get_genesis()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_headers","text":"Retrieves block headers matching given query. By default it will fetch current head slot blocks. Parameters: Name Type Description Default slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None parent_root Union [ Root , None] Restrict returned values to those matching the supplied parent_root None Source code in beacon_client/beacon_endpoints.py 231 232 233 234 235 236 237 238 239 240 241 242 243 def get_headers ( self , slot : Union [ Slot , None ] = None , parent_root : Union [ Root , None ] = None ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: slot: Restrict returned values to those matching the supplied slot parent_root: Restrict returned values to those matching the supplied parent_root \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } value = self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data","title":"get_headers()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_headers_from_block_id","text":"Retrieves block headers matching given query. By default it will fetch current head slot blocks. Parameters: Name Type Description Default block_id BlockId Return block header matching given block id required Source code in beacon_client/beacon_endpoints.py 245 246 247 248 249 250 251 252 253 def get_headers_from_block_id ( self , block_id : BlockId ) -> BeaconHeaderSummary : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. Args: block_id: Return block header matching given block id \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) data = parse_json ( value [ \"data\" ], BeaconHeaderSummary ) return data","title":"get_headers_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_attestations","text":"Retrieves attestations known by the node but not necessarily incorporated into any block Parameters: Name Type Description Default slot Union [ Slot , None] Restrict returned values to those matching the supplied slot None committee_index Union [ CommitteeIndex , None] Restrict returned values to those matching the supplied committee index None Source code in beacon_client/beacon_endpoints.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def get_pool_attestations ( self , slot : Union [ Slot , None ] = None , committee_index : Union [ CommitteeIndex , None ] = None , ) -> List [ Attestation ]: \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block Args: slot: Restrict returned values to those matching the supplied slot committee_index: Restrict returned values to those matching the supplied committee index \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } value = self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) data = parse_json ( value [ \"data\" ], Attestation ) return data","title":"get_pool_attestations()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_attester_slashings","text":"Retrieves attester slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 317 318 319 320 321 322 323 def get_pool_attester_slashings ( self ) -> list : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ]","title":"get_pool_attester_slashings()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_proposer_slashings","text":"Retrieves proposer slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 325 326 327 328 329 330 331 def get_pool_proposer_slashings ( self ) -> list : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ]","title":"get_pool_proposer_slashings()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_voluntary_exits","text":"Retrieves voluntary exits known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 333 334 335 336 337 338 339 def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" value = self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) # unparsed because it is very hard to test since slashing is rare return value [ \"data\" ]","title":"get_pool_voluntary_exits()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_state_root","text":"Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 40 41 42 43 44 45 46 47 48 49 def get_state_root ( self , state_id : StateId ) -> Root : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) data = Root ( value [ \"data\" ][ \"root\" ]) return data","title":"get_state_root()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_sync_committees_from_state","text":"Retrieves the sync committees for the given state. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required epoch Union [ Epoch , None] Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained None Source code in beacon_client/beacon_endpoints.py 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def get_sync_committees_from_state ( self , state_id : StateId , epoch : Union [ Epoch , None ] = None ) -> SyncCommitteeSummary : \"\"\" Retrieves the sync committees for the given state. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x epoch: Fetch committees for the given epoch. If not present then the committees for the epoch of the state will be obtained \"\"\" params = { \"epoch\" : epoch , } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) data = parse_json ( value [ \"data\" ], SyncCommitteeSummary ) return data","title":"get_sync_committees_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_balances_from_state","text":"Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_list Union [ List [ ValidatorId ], None] List of validators identified by public key or validator index None Source code in beacon_client/beacon_endpoints.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None ) -> List [ BalanceSummary ]: \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index \"\"\" params = { \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) data = parse_json ( value [ \"data\" ], BalanceSummary ) return data","title":"get_validators_balances_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_from_state","text":"Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_list Union [ List [ ValidatorId ], None] List of validators identified by public key or validator index None pending_initialized bool If true return validators with this status False pending_queued bool If true return validators with this status False active_ongoing bool If true return validators with this status False active_exiting bool If true return validators with this status False active_slashed bool If true return validators with this status False exited_unslashed bool If true return validators with this status False exited_slashed bool If true return validators with this status False withdrawal_possible bool If true return validators with this status False withdrawal_done bool If true return validators with this status False active bool If true return validators with this status False pending bool If true return validators with this status False exited bool If true return validators with this status False withdrawal bool If true return validators with this status False Source code in beacon_client/beacon_endpoints.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ List [ ValidatorId ], None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> List [ ValidatorSummary ]: \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_list: List of validators identified by public key or validator index pending_initialized: If true return validators with this status pending_queued: If true return validators with this status active_ongoing: If true return validators with this status active_exiting: If true return validators with this status active_slashed: If true return validators with this status exited_unslashed: If true return validators with this status exited_slashed: If true return validators with this status withdrawal_possible: If true return validators with this status withdrawal_done: If true return validators with this status active: If true return validators with this status pending: If true return validators with this status exited: If true return validators with this status withdrawal: If true return validators with this status \"\"\" status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data","title":"get_validators_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_from_state_by_id","text":"Returns validator specified by state and id or public key along with status and balance. Parameters: Name Type Description Default state_id StateId Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required validator_id ValidatorId Validator identified by public key or validator index required Source code in beacon_client/beacon_endpoints.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def get_validators_from_state_by_id ( self , state_id : StateId , validator_id : ValidatorId ) -> ValidatorSummary : \"\"\" Returns validator specified by state and id or public key along with status and balance. Args: state_id: Element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x validator_id: Validator identified by public key or validator index \"\"\" value = self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) data = parse_json ( value [ \"data\" ], ValidatorSummary ) return data","title":"get_validators_from_state_by_id()"},{"location":"config_endpoints/","text":"Config Endpoints beacon_client.config_endpoints.ConfigEndpoints Source code in beacon_client/config_endpoints.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ConfigEndpoints : def get_fork_schedule ( self ) -> List [ Fork ]: \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" value = self . _query_url ( \"/eth/v1/config/fork_schedule\" ) data = parse_json ( value [ \"data\" ], Fork ) return data def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" value = self . _query_url ( \"/eth/v1/config/spec\" ) return value [ \"data\" ] def get_deposit_contract ( self ) -> DepositContract : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" value = self . _query_url ( \"/eth/v1/config/deposit_contract\" ) data = parse_json ( value [ \"data\" ], DepositContract ) return data get_deposit_contract () Retrieve Eth1 deposit contract address and chain ID. Source code in beacon_client/config_endpoints.py 22 23 24 25 26 27 28 def get_deposit_contract ( self ) -> DepositContract : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" value = self . _query_url ( \"/eth/v1/config/deposit_contract\" ) data = parse_json ( value [ \"data\" ], DepositContract ) return data get_fork_schedule () Retrieve all forks, past present and future, of which this node is aware. Source code in beacon_client/config_endpoints.py 7 8 9 10 11 12 13 def get_fork_schedule ( self ) -> List [ Fork ]: \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" value = self . _query_url ( \"/eth/v1/config/fork_schedule\" ) data = parse_json ( value [ \"data\" ], Fork ) return data get_node_specification () Retrieve specification configuration used on this node. Source code in beacon_client/config_endpoints.py 15 16 17 18 19 20 def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" value = self . _query_url ( \"/eth/v1/config/spec\" ) return value [ \"data\" ]","title":"Config Endpoints"},{"location":"config_endpoints/#config-endpoints","text":"","title":"Config Endpoints"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints","text":"Source code in beacon_client/config_endpoints.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class ConfigEndpoints : def get_fork_schedule ( self ) -> List [ Fork ]: \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" value = self . _query_url ( \"/eth/v1/config/fork_schedule\" ) data = parse_json ( value [ \"data\" ], Fork ) return data def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" value = self . _query_url ( \"/eth/v1/config/spec\" ) return value [ \"data\" ] def get_deposit_contract ( self ) -> DepositContract : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" value = self . _query_url ( \"/eth/v1/config/deposit_contract\" ) data = parse_json ( value [ \"data\" ], DepositContract ) return data","title":"ConfigEndpoints"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_deposit_contract","text":"Retrieve Eth1 deposit contract address and chain ID. Source code in beacon_client/config_endpoints.py 22 23 24 25 26 27 28 def get_deposit_contract ( self ) -> DepositContract : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" value = self . _query_url ( \"/eth/v1/config/deposit_contract\" ) data = parse_json ( value [ \"data\" ], DepositContract ) return data","title":"get_deposit_contract()"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_fork_schedule","text":"Retrieve all forks, past present and future, of which this node is aware. Source code in beacon_client/config_endpoints.py 7 8 9 10 11 12 13 def get_fork_schedule ( self ) -> List [ Fork ]: \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" value = self . _query_url ( \"/eth/v1/config/fork_schedule\" ) data = parse_json ( value [ \"data\" ], Fork ) return data","title":"get_fork_schedule()"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_node_specification","text":"Retrieve specification configuration used on this node. Source code in beacon_client/config_endpoints.py 15 16 17 18 19 20 def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" value = self . _query_url ( \"/eth/v1/config/spec\" ) return value [ \"data\" ]","title":"get_node_specification()"},{"location":"debug_endpoints/","text":"Debug Endpoints Currently unimplemented beacon_client.debug_endpoints.DebugEndpoints Source code in beacon_client/debug_endpoints.py 1 2 class DebugEndpoints : pass","title":"Debug Endpoints"},{"location":"debug_endpoints/#debug-endpoints","text":"","title":"Debug Endpoints"},{"location":"debug_endpoints/#currently-unimplemented","text":"","title":"Currently unimplemented"},{"location":"debug_endpoints/#beacon_client.debug_endpoints.DebugEndpoints","text":"Source code in beacon_client/debug_endpoints.py 1 2 class DebugEndpoints : pass","title":"DebugEndpoints"},{"location":"event_endpoints/","text":"Event Endpoints beacon_client.event_endpoints.EventEndpoints Source code in beacon_client/event_endpoints.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class EventEndpoints : def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Args: head: If true return events of type head block: If true return events of type block attestation: If true return events of type attestation voluntary_exit: If true return events of type voluntary_exit finalized_checkpoint: If true return events of type finalized_checkpoint chain_reorg: If true return events of type chain_reorg contribution_and_proof: If true return events of type contribution_and_proof \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events () @staticmethod def parse_head ( data ): data = parse_json ( json . loads ( data ), StreamedHead ) return data @staticmethod def parse_block ( data ): data = parse_json ( json . loads ( data ), StreamedBlock ) return data @staticmethod def parse_attestation ( data ): data = parse_json ( json . loads ( data ), Attestation ) return data @staticmethod def parse_checkpoint ( data ): data = parse_json ( json . loads ( data ), StreamedCheckpoint ) return data stream_events ( head = False , block = False , attestation = False , voluntary_exit = False , finalized_checkpoint = False , chain_reorg = False , contribution_and_proof = False ) Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Parameters: Name Type Description Default head bool If true return events of type head False block bool If true return events of type block False attestation bool If true return events of type attestation False voluntary_exit bool If true return events of type voluntary_exit False finalized_checkpoint bool If true return events of type finalized_checkpoint False chain_reorg bool If true return events of type chain_reorg False contribution_and_proof bool If true return events of type contribution_and_proof False Source code in beacon_client/event_endpoints.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Args: head: If true return events of type head block: If true return events of type block attestation: If true return events of type attestation voluntary_exit: If true return events of type voluntary_exit finalized_checkpoint: If true return events of type finalized_checkpoint chain_reorg: If true return events of type chain_reorg contribution_and_proof: If true return events of type contribution_and_proof \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events ()","title":"Event Endpoints"},{"location":"event_endpoints/#event-endpoints","text":"","title":"Event Endpoints"},{"location":"event_endpoints/#beacon_client.event_endpoints.EventEndpoints","text":"Source code in beacon_client/event_endpoints.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class EventEndpoints : def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Args: head: If true return events of type head block: If true return events of type block attestation: If true return events of type attestation voluntary_exit: If true return events of type voluntary_exit finalized_checkpoint: If true return events of type finalized_checkpoint chain_reorg: If true return events of type chain_reorg contribution_and_proof: If true return events of type contribution_and_proof \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events () @staticmethod def parse_head ( data ): data = parse_json ( json . loads ( data ), StreamedHead ) return data @staticmethod def parse_block ( data ): data = parse_json ( json . loads ( data ), StreamedBlock ) return data @staticmethod def parse_attestation ( data ): data = parse_json ( json . loads ( data ), Attestation ) return data @staticmethod def parse_checkpoint ( data ): data = parse_json ( json . loads ( data ), StreamedCheckpoint ) return data","title":"EventEndpoints"},{"location":"event_endpoints/#beacon_client.event_endpoints.EventEndpoints.stream_events","text":"Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Parameters: Name Type Description Default head bool If true return events of type head False block bool If true return events of type block False attestation bool If true return events of type attestation False voluntary_exit bool If true return events of type voluntary_exit False finalized_checkpoint bool If true return events of type finalized_checkpoint False chain_reorg bool If true return events of type chain_reorg False contribution_and_proof bool If true return events of type contribution_and_proof False Source code in beacon_client/event_endpoints.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Args: head: If true return events of type head block: If true return events of type block attestation: If true return events of type attestation voluntary_exit: If true return events of type voluntary_exit finalized_checkpoint: If true return events of type finalized_checkpoint chain_reorg: If true return events of type chain_reorg contribution_and_proof: If true return events of type contribution_and_proof \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events ()","title":"stream_events()"},{"location":"node_endpoints/","text":"Node Endpoints beacon_client.node_endpoints.NodeEndpoints Source code in beacon_client/node_endpoints.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class NodeEndpoints : def get_node_identity ( self ) -> NetworkIdentity : \"\"\" Retrieves data about the node's network presence \"\"\" value = self . _query_url ( \"/eth/v1/node/identity\" ) data = parse_json ( value [ \"data\" ], NetworkIdentity ) return data def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ) -> List [ PeerDescription ]: \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Args: disconnected: If true return nodes with status disconnected disconnecting: If true return nodes with status disconnecting connected: If true return nodes with status connected connecting: If true return nodes with status connecting inbound: If true return nodes with direction inbound outbound: If true return nodes with direction outbound \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } value = self . _query_url ( \"/eth/v1/node/peers\" , params = params ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data def get_peer_by_id ( self , peer_id : PeerId ) -> PeerDescription : \"\"\" Retrieves data about the given peer Args: peer_id: Return peer for given peer id \"\"\" value = self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data def get_peer_count ( self ) -> PeerSummary : \"\"\" Retrieves number of known peers. \"\"\" value = self . _query_url ( \"/eth/v1/node/peer_count\" ) data = parse_json ( value [ \"data\" ], PeerSummary ) return data def get_node_version ( self ) -> str : \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" )[ \"data\" ][ \"version\" ] def get_syncing_status ( self ) -> SyncStatus : \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" value = self . _query_url ( \"/eth/v1/node/syncing\" ) data = parse_json ( value [ \"data\" ], SyncStatus ) return data get_node_identity () Retrieves data about the node's network presence Source code in beacon_client/node_endpoints.py 7 8 9 10 11 12 13 def get_node_identity ( self ) -> NetworkIdentity : \"\"\" Retrieves data about the node's network presence \"\"\" value = self . _query_url ( \"/eth/v1/node/identity\" ) data = parse_json ( value [ \"data\" ], NetworkIdentity ) return data get_node_peers ( disconnected = False , disconnecting = False , connected = False , connecting = False , inbound = False , outbound = False ) Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Parameters: Name Type Description Default disconnected bool If true return nodes with status disconnected False disconnecting bool If true return nodes with status disconnecting False connected bool If true return nodes with status connected False connecting bool If true return nodes with status connecting False inbound bool If true return nodes with direction inbound False outbound bool If true return nodes with direction outbound False Source code in beacon_client/node_endpoints.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ) -> List [ PeerDescription ]: \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Args: disconnected: If true return nodes with status disconnected disconnecting: If true return nodes with status disconnecting connected: If true return nodes with status connected connecting: If true return nodes with status connecting inbound: If true return nodes with direction inbound outbound: If true return nodes with direction outbound \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } value = self . _query_url ( \"/eth/v1/node/peers\" , params = params ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data get_node_version () Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. Source code in beacon_client/node_endpoints.py 79 80 81 82 83 def get_node_version ( self ) -> str : \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" )[ \"data\" ][ \"version\" ] get_peer_by_id ( peer_id ) Retrieves data about the given peer Parameters: Name Type Description Default peer_id PeerId Return peer for given peer id required Source code in beacon_client/node_endpoints.py 61 62 63 64 65 66 67 68 69 def get_peer_by_id ( self , peer_id : PeerId ) -> PeerDescription : \"\"\" Retrieves data about the given peer Args: peer_id: Return peer for given peer id \"\"\" value = self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data get_peer_count () Retrieves number of known peers. Source code in beacon_client/node_endpoints.py 71 72 73 74 75 76 77 def get_peer_count ( self ) -> PeerSummary : \"\"\" Retrieves number of known peers. \"\"\" value = self . _query_url ( \"/eth/v1/node/peer_count\" ) data = parse_json ( value [ \"data\" ], PeerSummary ) return data get_syncing_status () Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. Source code in beacon_client/node_endpoints.py 85 86 87 88 89 90 91 def get_syncing_status ( self ) -> SyncStatus : \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" value = self . _query_url ( \"/eth/v1/node/syncing\" ) data = parse_json ( value [ \"data\" ], SyncStatus ) return data","title":"Node Endpoints"},{"location":"node_endpoints/#node-endpoints","text":"","title":"Node Endpoints"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints","text":"Source code in beacon_client/node_endpoints.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class NodeEndpoints : def get_node_identity ( self ) -> NetworkIdentity : \"\"\" Retrieves data about the node's network presence \"\"\" value = self . _query_url ( \"/eth/v1/node/identity\" ) data = parse_json ( value [ \"data\" ], NetworkIdentity ) return data def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ) -> List [ PeerDescription ]: \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Args: disconnected: If true return nodes with status disconnected disconnecting: If true return nodes with status disconnecting connected: If true return nodes with status connected connecting: If true return nodes with status connecting inbound: If true return nodes with direction inbound outbound: If true return nodes with direction outbound \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } value = self . _query_url ( \"/eth/v1/node/peers\" , params = params ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data def get_peer_by_id ( self , peer_id : PeerId ) -> PeerDescription : \"\"\" Retrieves data about the given peer Args: peer_id: Return peer for given peer id \"\"\" value = self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data def get_peer_count ( self ) -> PeerSummary : \"\"\" Retrieves number of known peers. \"\"\" value = self . _query_url ( \"/eth/v1/node/peer_count\" ) data = parse_json ( value [ \"data\" ], PeerSummary ) return data def get_node_version ( self ) -> str : \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" )[ \"data\" ][ \"version\" ] def get_syncing_status ( self ) -> SyncStatus : \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" value = self . _query_url ( \"/eth/v1/node/syncing\" ) data = parse_json ( value [ \"data\" ], SyncStatus ) return data","title":"NodeEndpoints"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_identity","text":"Retrieves data about the node's network presence Source code in beacon_client/node_endpoints.py 7 8 9 10 11 12 13 def get_node_identity ( self ) -> NetworkIdentity : \"\"\" Retrieves data about the node's network presence \"\"\" value = self . _query_url ( \"/eth/v1/node/identity\" ) data = parse_json ( value [ \"data\" ], NetworkIdentity ) return data","title":"get_node_identity()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_peers","text":"Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Parameters: Name Type Description Default disconnected bool If true return nodes with status disconnected False disconnecting bool If true return nodes with status disconnecting False connected bool If true return nodes with status connected False connecting bool If true return nodes with status connecting False inbound bool If true return nodes with direction inbound False outbound bool If true return nodes with direction outbound False Source code in beacon_client/node_endpoints.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ) -> List [ PeerDescription ]: \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Args: disconnected: If true return nodes with status disconnected disconnecting: If true return nodes with status disconnecting connected: If true return nodes with status connected connecting: If true return nodes with status connecting inbound: If true return nodes with direction inbound outbound: If true return nodes with direction outbound \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } value = self . _query_url ( \"/eth/v1/node/peers\" , params = params ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data","title":"get_node_peers()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_version","text":"Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. Source code in beacon_client/node_endpoints.py 79 80 81 82 83 def get_node_version ( self ) -> str : \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" )[ \"data\" ][ \"version\" ]","title":"get_node_version()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_peer_by_id","text":"Retrieves data about the given peer Parameters: Name Type Description Default peer_id PeerId Return peer for given peer id required Source code in beacon_client/node_endpoints.py 61 62 63 64 65 66 67 68 69 def get_peer_by_id ( self , peer_id : PeerId ) -> PeerDescription : \"\"\" Retrieves data about the given peer Args: peer_id: Return peer for given peer id \"\"\" value = self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) data = parse_json ( value [ \"data\" ], PeerDescription ) return data","title":"get_peer_by_id()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_peer_count","text":"Retrieves number of known peers. Source code in beacon_client/node_endpoints.py 71 72 73 74 75 76 77 def get_peer_count ( self ) -> PeerSummary : \"\"\" Retrieves number of known peers. \"\"\" value = self . _query_url ( \"/eth/v1/node/peer_count\" ) data = parse_json ( value [ \"data\" ], PeerSummary ) return data","title":"get_peer_count()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_syncing_status","text":"Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. Source code in beacon_client/node_endpoints.py 85 86 87 88 89 90 91 def get_syncing_status ( self ) -> SyncStatus : \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" value = self . _query_url ( \"/eth/v1/node/syncing\" ) data = parse_json ( value [ \"data\" ], SyncStatus ) return data","title":"get_syncing_status()"},{"location":"validator_endpoints/","text":"Validator Endpoints Currently mostly unimplemented beacon_client.validator_endpoints.ValidatorEndpoints Source code in beacon_client/validator_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ValidatorEndpoints : def get_block_proposers_duties ( self , epoch : int ) -> dict : \"\"\" Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Args: epoch: provide all proposers for the given epoch value \"\"\" return self . _query_url ( f \"/eth/v1/validator/duties/proposer/ { epoch } \" ) get_block_proposers_duties ( epoch ) Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Parameters: Name Type Description Default epoch int provide all proposers for the given epoch value required Source code in beacon_client/validator_endpoints.py 2 3 4 5 6 7 8 9 10 11 12 13 14 def get_block_proposers_duties ( self , epoch : int ) -> dict : \"\"\" Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Args: epoch: provide all proposers for the given epoch value \"\"\" return self . _query_url ( f \"/eth/v1/validator/duties/proposer/ { epoch } \" )","title":"Validator Endpoints"},{"location":"validator_endpoints/#validator-endpoints","text":"","title":"Validator Endpoints"},{"location":"validator_endpoints/#currently-mostly-unimplemented","text":"","title":"Currently mostly unimplemented"},{"location":"validator_endpoints/#beacon_client.validator_endpoints.ValidatorEndpoints","text":"Source code in beacon_client/validator_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ValidatorEndpoints : def get_block_proposers_duties ( self , epoch : int ) -> dict : \"\"\" Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Args: epoch: provide all proposers for the given epoch value \"\"\" return self . _query_url ( f \"/eth/v1/validator/duties/proposer/ { epoch } \" )","title":"ValidatorEndpoints"},{"location":"validator_endpoints/#beacon_client.validator_endpoints.ValidatorEndpoints.get_block_proposers_duties","text":"Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Parameters: Name Type Description Default epoch int provide all proposers for the given epoch value required Source code in beacon_client/validator_endpoints.py 2 3 4 5 6 7 8 9 10 11 12 13 14 def get_block_proposers_duties ( self , epoch : int ) -> dict : \"\"\" Request beacon node to provide all validators that are scheduled to propose a block in the given epoch. Duties should only need to be checked once per epoch, however a chain reorganization could occur that results in a change of duties. For full safety, you should monitor head events and confirm the dependent root in this response matches: event.current_duty_dependent_root when compute_epoch_at_slot(event.slot) == epoch event.block otherwise The dependent_root value is get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch) - 1) or the genesis block root in the case of underflow. Args: epoch: provide all proposers for the given epoch value \"\"\" return self . _query_url ( f \"/eth/v1/validator/duties/proposer/ { epoch } \" )","title":"get_block_proposers_duties()"}]}