{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About A Python client for interacting with the Ethereum Beacon Chain API Reference: https://ethereum.github.io/beacon-APIs/ Simple Example from beacon_client.api import BeaconChainAPI api = BeaconChainAPI(\"http://localhost:5052\") api.get_block_from_block_id(block_id=\"head\", response_type=\"json\") Streaming Example for event in api.stream_events(head=True, block=True): print(event.event) print(json.loads(event.data))","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about","text":"A Python client for interacting with the Ethereum Beacon Chain API Reference: https://ethereum.github.io/beacon-APIs/","title":"About"},{"location":"#simple-example","text":"from beacon_client.api import BeaconChainAPI api = BeaconChainAPI(\"http://localhost:5052\") api.get_block_from_block_id(block_id=\"head\", response_type=\"json\")","title":"Simple Example"},{"location":"#streaming-example","text":"for event in api.stream_events(head=True, block=True): print(event.event) print(json.loads(event.data))","title":"Streaming Example"},{"location":"beacon_endpoints/","text":"Beacon Endpoints beacon_client.beacon_endpoints.BeaconEndpoints Source code in beacon_client/beacon_endpoints.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 class BeaconEndpoints : StateId = Union [ str , int ] @staticmethod def _check_state_id ( state_id : StateId ) -> None : if isinstance ( state_id , str ) and not state_id . startswith ( \"0x\" ): assert state_id in [ \"head\" , \"genesis\" , \"finalized\" , \"justified\" , ], \"state_id must be in [head, genesis, finalized, justified] or block number (int) or start with 0x\" def get_genesis ( self ) -> dict : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" return self . _query_url ( \"/eth/v1/beacon/genesis\" ) def get_state_root ( self , state_id : StateId ) -> dict : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) def get_fork_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns Fork object for state with given 'state_id'. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> dict : \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. \"\"\" self . _check_state_id ( state_id ) status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) def get_validators_from_state_by_id ( self , state_id : StateId , validator_id ) -> dict : \"\"\" Returns validator specified by state and id or public key along with status and balance. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None ) -> dict : \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. \"\"\" params = { \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) def get_committees_from_state ( self , state_id : StateId , epoch : Union [ int , None ] = None , index : Union [ int , None ] = None , slot : Union [ int , None ] = None , ) -> dict : \"\"\" Retrieves the committees for the given state. \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) def get_sync_committees_from_state ( self , state_id , epoch : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves the sync committees for the given state. \"\"\" params = { \"epoch\" : epoch , } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) def get_headers ( self , slot : Union [ int , None ] = None , parent_root : Union [ str , None ] = None ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } return self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) def get_headers_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) def get_block_from_block_id ( self , block_id , response_type : str = \"json\" ) -> Union [ dict , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] \"\"\" assert response_type in [ \"json\" , \"ssz\" ], \"response_type must be in [json, ssz]\" if response_type == \"json\" : headers = { \"Accept\" : \"application/json\" } if response_type == \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) def get_block_root_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) def get_attestations_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves attestation included in requested block. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) def get_pool_attestations ( self , slot : Union [ int , None ] = None , committee_index : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } return self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) def get_pool_attester_slashings ( self ) -> dict : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) def get_pool_proposer_slashings ( self ) -> dict : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) get_attestations_from_block_id ( block_id ) Retrieves attestation included in requested block. Source code in beacon_client/beacon_endpoints.py 199 200 201 202 203 def get_attestations_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves attestation included in requested block. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) get_block_from_block_id ( block_id , response_type = 'json' ) Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Source code in beacon_client/beacon_endpoints.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_block_from_block_id ( self , block_id , response_type : str = \"json\" ) -> Union [ dict , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] \"\"\" assert response_type in [ \"json\" , \"ssz\" ], \"response_type must be in [json, ssz]\" if response_type == \"json\" : headers = { \"Accept\" : \"application/json\" } if response_type == \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) get_block_root_from_block_id ( block_id ) Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Source code in beacon_client/beacon_endpoints.py 193 194 195 196 197 def get_block_root_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) get_committees_from_state ( state_id , epoch = None , index = None , slot = None ) Retrieves the committees for the given state. Source code in beacon_client/beacon_endpoints.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def get_committees_from_state ( self , state_id : StateId , epoch : Union [ int , None ] = None , index : Union [ int , None ] = None , slot : Union [ int , None ] = None , ) -> dict : \"\"\" Retrieves the committees for the given state. \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) get_finality_checkpoints_from_state ( state_id ) Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Source code in beacon_client/beacon_endpoints.py 40 41 42 43 44 45 46 def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) get_fork_from_state ( state_id ) Returns Fork object for state with given 'state_id'. Source code in beacon_client/beacon_endpoints.py 33 34 35 36 37 38 def get_fork_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns Fork object for state with given 'state_id'. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) get_genesis () Retrieve details of the chain's genesis which can be used to identify chain. Source code in beacon_client/beacon_endpoints.py 17 18 19 20 21 def get_genesis ( self ) -> dict : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" return self . _query_url ( \"/eth/v1/beacon/genesis\" ) get_headers ( slot = None , parent_root = None ) Retrieves block headers matching given query. By default it will fetch current head slot blocks. Source code in beacon_client/beacon_endpoints.py 163 164 165 166 167 168 169 170 def get_headers ( self , slot : Union [ int , None ] = None , parent_root : Union [ str , None ] = None ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } return self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) get_headers_from_block_id ( block_id ) Retrieves block headers matching given query. By default it will fetch current head slot blocks. Source code in beacon_client/beacon_endpoints.py 172 173 174 175 176 def get_headers_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) get_pool_attestations ( slot = None , committee_index = None ) Retrieves attestations known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 205 206 207 208 209 210 211 212 def get_pool_attestations ( self , slot : Union [ int , None ] = None , committee_index : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } return self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) get_pool_attester_slashings () Retrieves attester slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 214 215 216 217 218 def get_pool_attester_slashings ( self ) -> dict : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) get_pool_proposer_slashings () Retrieves proposer slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 220 221 222 223 224 def get_pool_proposer_slashings ( self ) -> dict : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) get_pool_voluntary_exits () Retrieves voluntary exits known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 226 227 228 229 230 def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" ) get_state_root ( state_id ) Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Parameters: Name Type Description Default state_id StateId element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 23 24 25 26 27 28 29 30 31 def get_state_root ( self , state_id : StateId ) -> dict : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) get_sync_committees_from_state ( state_id , epoch = None ) Retrieves the sync committees for the given state. Source code in beacon_client/beacon_endpoints.py 150 151 152 153 154 155 156 157 158 159 160 161 def get_sync_committees_from_state ( self , state_id , epoch : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves the sync committees for the given state. \"\"\" params = { \"epoch\" : epoch , } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) get_validators_balances_from_state ( state_id , validator_list = None ) Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Source code in beacon_client/beacon_endpoints.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None ) -> dict : \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. \"\"\" params = { \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) get_validators_from_state ( state_id , validator_list = None , pending_initialized = False , pending_queued = False , active_ongoing = False , active_exiting = False , active_slashed = False , exited_unslashed = False , exited_slashed = False , withdrawal_possible = False , withdrawal_done = False , active = False , pending = False , exited = False , withdrawal = False ) Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Source code in beacon_client/beacon_endpoints.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> dict : \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. \"\"\" self . _check_state_id ( state_id ) status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) get_validators_from_state_by_id ( state_id , validator_id ) Returns validator specified by state and id or public key along with status and balance. Source code in beacon_client/beacon_endpoints.py 109 110 111 112 113 114 115 116 def get_validators_from_state_by_id ( self , state_id : StateId , validator_id ) -> dict : \"\"\" Returns validator specified by state and id or public key along with status and balance. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" )","title":"Beacon Endpoints"},{"location":"beacon_endpoints/#beacon-endpoints","text":"","title":"Beacon Endpoints"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints","text":"Source code in beacon_client/beacon_endpoints.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 class BeaconEndpoints : StateId = Union [ str , int ] @staticmethod def _check_state_id ( state_id : StateId ) -> None : if isinstance ( state_id , str ) and not state_id . startswith ( \"0x\" ): assert state_id in [ \"head\" , \"genesis\" , \"finalized\" , \"justified\" , ], \"state_id must be in [head, genesis, finalized, justified] or block number (int) or start with 0x\" def get_genesis ( self ) -> dict : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" return self . _query_url ( \"/eth/v1/beacon/genesis\" ) def get_state_root ( self , state_id : StateId ) -> dict : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" ) def get_fork_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns Fork object for state with given 'state_id'. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" ) def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" ) def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> dict : \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. \"\"\" self . _check_state_id ( state_id ) status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params ) def get_validators_from_state_by_id ( self , state_id : StateId , validator_id ) -> dict : \"\"\" Returns validator specified by state and id or public key along with status and balance. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" ) def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None ) -> dict : \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. \"\"\" params = { \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params ) def get_committees_from_state ( self , state_id : StateId , epoch : Union [ int , None ] = None , index : Union [ int , None ] = None , slot : Union [ int , None ] = None , ) -> dict : \"\"\" Retrieves the committees for the given state. \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params ) def get_sync_committees_from_state ( self , state_id , epoch : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves the sync committees for the given state. \"\"\" params = { \"epoch\" : epoch , } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params ) def get_headers ( self , slot : Union [ int , None ] = None , parent_root : Union [ str , None ] = None ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } return self . _query_url ( \"/eth/v1/beacon/headers\" , params = params ) def get_headers_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" ) def get_block_from_block_id ( self , block_id , response_type : str = \"json\" ) -> Union [ dict , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] \"\"\" assert response_type in [ \"json\" , \"ssz\" ], \"response_type must be in [json, ssz]\" if response_type == \"json\" : headers = { \"Accept\" : \"application/json\" } if response_type == \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers ) def get_block_root_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" ) def get_attestations_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves attestation included in requested block. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" ) def get_pool_attestations ( self , slot : Union [ int , None ] = None , committee_index : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } return self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params ) def get_pool_attester_slashings ( self ) -> dict : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" ) def get_pool_proposer_slashings ( self ) -> dict : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" ) def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" )","title":"BeaconEndpoints"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_attestations_from_block_id","text":"Retrieves attestation included in requested block. Source code in beacon_client/beacon_endpoints.py 199 200 201 202 203 def get_attestations_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves attestation included in requested block. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /attestations\" )","title":"get_attestations_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_block_from_block_id","text":"Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] Source code in beacon_client/beacon_endpoints.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def get_block_from_block_id ( self , block_id , response_type : str = \"json\" ) -> Union [ dict , str ]: \"\"\" Retrieves block details for given block id. Depending on Accept header it can be returned either as json or as bytes serialized by SSZ response_type in [json, ssz] \"\"\" assert response_type in [ \"json\" , \"ssz\" ], \"response_type must be in [json, ssz]\" if response_type == \"json\" : headers = { \"Accept\" : \"application/json\" } if response_type == \"ssz\" : headers = { \"Accept\" : \"application/octet-stream\" } return self . _query_url ( f \"/eth/v2/beacon/blocks/ { block_id } \" , headers = headers )","title":"get_block_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_block_root_from_block_id","text":"Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader Source code in beacon_client/beacon_endpoints.py 193 194 195 196 197 def get_block_root_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader \"\"\" return self . _query_url ( f \"/eth/v1/beacon/blocks/ { block_id } /root\" )","title":"get_block_root_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_committees_from_state","text":"Retrieves the committees for the given state. Source code in beacon_client/beacon_endpoints.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def get_committees_from_state ( self , state_id : StateId , epoch : Union [ int , None ] = None , index : Union [ int , None ] = None , slot : Union [ int , None ] = None , ) -> dict : \"\"\" Retrieves the committees for the given state. \"\"\" params = { \"epoch\" : epoch , \"index\" : index , \"slot\" : slot } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /committees\" , params = params )","title":"get_committees_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_finality_checkpoints_from_state","text":"Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. Source code in beacon_client/beacon_endpoints.py 40 41 42 43 44 45 46 def get_finality_checkpoints_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns finality checkpoints for state with given 'state_id'. In case finality is not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /finality_checkpoints\" )","title":"get_finality_checkpoints_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_fork_from_state","text":"Returns Fork object for state with given 'state_id'. Source code in beacon_client/beacon_endpoints.py 33 34 35 36 37 38 def get_fork_from_state ( self , state_id : StateId ) -> dict : \"\"\" Returns Fork object for state with given 'state_id'. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /fork\" )","title":"get_fork_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_genesis","text":"Retrieve details of the chain's genesis which can be used to identify chain. Source code in beacon_client/beacon_endpoints.py 17 18 19 20 21 def get_genesis ( self ) -> dict : \"\"\" Retrieve details of the chain's genesis which can be used to identify chain. \"\"\" return self . _query_url ( \"/eth/v1/beacon/genesis\" )","title":"get_genesis()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_headers","text":"Retrieves block headers matching given query. By default it will fetch current head slot blocks. Source code in beacon_client/beacon_endpoints.py 163 164 165 166 167 168 169 170 def get_headers ( self , slot : Union [ int , None ] = None , parent_root : Union [ str , None ] = None ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" params = { \"slot\" : slot , \"parent_root\" : parent_root } return self . _query_url ( \"/eth/v1/beacon/headers\" , params = params )","title":"get_headers()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_headers_from_block_id","text":"Retrieves block headers matching given query. By default it will fetch current head slot blocks. Source code in beacon_client/beacon_endpoints.py 172 173 174 175 176 def get_headers_from_block_id ( self , block_id ) -> dict : \"\"\" Retrieves block headers matching given query. By default it will fetch current head slot blocks. \"\"\" return self . _query_url ( f \"/eth/v1/beacon/headers/ { block_id } \" )","title":"get_headers_from_block_id()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_attestations","text":"Retrieves attestations known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 205 206 207 208 209 210 211 212 def get_pool_attestations ( self , slot : Union [ int , None ] = None , committee_index : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves attestations known by the node but not necessarily incorporated into any block \"\"\" params = { \"slot\" : slot , \"committee_index\" : committee_index } return self . _query_url ( \"/eth/v1/beacon/pool/attestations\" , params = params )","title":"get_pool_attestations()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_attester_slashings","text":"Retrieves attester slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 214 215 216 217 218 def get_pool_attester_slashings ( self ) -> dict : \"\"\" Retrieves attester slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/attester_slashings\" )","title":"get_pool_attester_slashings()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_proposer_slashings","text":"Retrieves proposer slashings known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 220 221 222 223 224 def get_pool_proposer_slashings ( self ) -> dict : \"\"\" Retrieves proposer slashings known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/proposer_slashings\" )","title":"get_pool_proposer_slashings()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_pool_voluntary_exits","text":"Retrieves voluntary exits known by the node but not necessarily incorporated into any block Source code in beacon_client/beacon_endpoints.py 226 227 228 229 230 def get_pool_voluntary_exits ( self ) -> dict : \"\"\" Retrieves voluntary exits known by the node but not necessarily incorporated into any block \"\"\" return self . _query_url ( \"/eth/v1/beacon/pool/voluntary_exits\" )","title":"get_pool_voluntary_exits()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_state_root","text":"Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Parameters: Name Type Description Default state_id StateId element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x required Source code in beacon_client/beacon_endpoints.py 23 24 25 26 27 28 29 30 31 def get_state_root ( self , state_id : StateId ) -> dict : \"\"\" Calculates HashTreeRoot for state with given 'state_id'. If state_id is root, same value will be returned. Args: state_id: element of [head, genesis, finalized, justified] or block number (int) or string starting with 0x \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /root\" )","title":"get_state_root()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_sync_committees_from_state","text":"Retrieves the sync committees for the given state. Source code in beacon_client/beacon_endpoints.py 150 151 152 153 154 155 156 157 158 159 160 161 def get_sync_committees_from_state ( self , state_id , epoch : Union [ int , None ] = None ) -> dict : \"\"\" Retrieves the sync committees for the given state. \"\"\" params = { \"epoch\" : epoch , } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /sync_committees\" , params = params )","title":"get_sync_committees_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_balances_from_state","text":"Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. Source code in beacon_client/beacon_endpoints.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def get_validators_balances_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None ) -> dict : \"\"\" Returns filterable list of validators balances. Balances will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no balance will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; the index and is returned for each balance, and can be used to confirm for which inputs a response has been returned. \"\"\" params = { \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validator_balances\" , params = params )","title":"get_validators_balances_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_from_state","text":"Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. Source code in beacon_client/beacon_endpoints.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_validators_from_state ( self , state_id : StateId , validator_list : Union [ list , None ] = None , pending_initialized : bool = False , pending_queued : bool = False , active_ongoing : bool = False , active_exiting : bool = False , active_slashed : bool = False , exited_unslashed : bool = False , exited_slashed : bool = False , withdrawal_possible : bool = False , withdrawal_done : bool = False , active : bool = False , pending : bool = False , exited : bool = False , withdrawal : bool = False , ) -> dict : \"\"\" Returns filterable list of validators with their balance, status and index. Information will be returned for all indices or public key that match known validators. If an index or public key does not match any known validator, no information will be returned but this will not cause an error. There are no guarantees for the returned data in terms of ordering; both the index and public key are returned for each validator, and can be used to confirm for which inputs a response has been returned. \"\"\" self . _check_state_id ( state_id ) status = [] if pending_initialized : status . append ( \"pending_initialized\" ) if pending_queued : status . append ( \"pending_queued\" ) if active_ongoing : status . append ( \"active_ongoing\" ) if active_exiting : status . append ( \"active_exiting\" ) if active_slashed : status . append ( \"active_slashed\" ) if exited_unslashed : status . append ( \"exited_unslashed\" ) if exited_slashed : status . append ( \"exited_slashed\" ) if withdrawal_possible : status . append ( \"withdrawal_possible\" ) if withdrawal_done : status . append ( \"withdrawal_done\" ) if active : status . append ( \"active\" ) if pending : status . append ( \"pending\" ) if exited : status . append ( \"exited\" ) if withdrawal : status . append ( \"withdrawal\" ) assert len ( status ) > 0 , \"Select at least one validator condition\" params = { \"status\" : status , \"id\" : validator_list } return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators\" , params = params )","title":"get_validators_from_state()"},{"location":"beacon_endpoints/#beacon_client.beacon_endpoints.BeaconEndpoints.get_validators_from_state_by_id","text":"Returns validator specified by state and id or public key along with status and balance. Source code in beacon_client/beacon_endpoints.py 109 110 111 112 113 114 115 116 def get_validators_from_state_by_id ( self , state_id : StateId , validator_id ) -> dict : \"\"\" Returns validator specified by state and id or public key along with status and balance. \"\"\" self . _check_state_id ( state_id ) return self . _query_url ( f \"/eth/v1/beacon/states/ { state_id } /validators/ { validator_id } \" )","title":"get_validators_from_state_by_id()"},{"location":"config_endpoints/","text":"Config Endpoints beacon_client.config_endpoints.ConfigEndpoints Source code in beacon_client/config_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class ConfigEndpoints : def get_fork_schedule ( self ) -> dict : \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" return self . _query_url ( \"/eth/v1/config/fork_schedule\" ) def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" return self . _query_url ( \"/eth/v1/config/spec\" ) def get_deposit_contract ( self ) -> dict : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" return self . _query_url ( \"/eth/v1/config/deposit_contract\" ) get_deposit_contract () Retrieve Eth1 deposit contract address and chain ID. Source code in beacon_client/config_endpoints.py 14 15 16 17 18 def get_deposit_contract ( self ) -> dict : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" return self . _query_url ( \"/eth/v1/config/deposit_contract\" ) get_fork_schedule () Retrieve all forks, past present and future, of which this node is aware. Source code in beacon_client/config_endpoints.py 2 3 4 5 6 def get_fork_schedule ( self ) -> dict : \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" return self . _query_url ( \"/eth/v1/config/fork_schedule\" ) get_node_specification () Retrieve specification configuration used on this node. Source code in beacon_client/config_endpoints.py 8 9 10 11 12 def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" return self . _query_url ( \"/eth/v1/config/spec\" )","title":"Config Endpoints"},{"location":"config_endpoints/#config-endpoints","text":"","title":"Config Endpoints"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints","text":"Source code in beacon_client/config_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class ConfigEndpoints : def get_fork_schedule ( self ) -> dict : \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" return self . _query_url ( \"/eth/v1/config/fork_schedule\" ) def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" return self . _query_url ( \"/eth/v1/config/spec\" ) def get_deposit_contract ( self ) -> dict : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" return self . _query_url ( \"/eth/v1/config/deposit_contract\" )","title":"ConfigEndpoints"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_deposit_contract","text":"Retrieve Eth1 deposit contract address and chain ID. Source code in beacon_client/config_endpoints.py 14 15 16 17 18 def get_deposit_contract ( self ) -> dict : \"\"\" Retrieve Eth1 deposit contract address and chain ID. \"\"\" return self . _query_url ( \"/eth/v1/config/deposit_contract\" )","title":"get_deposit_contract()"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_fork_schedule","text":"Retrieve all forks, past present and future, of which this node is aware. Source code in beacon_client/config_endpoints.py 2 3 4 5 6 def get_fork_schedule ( self ) -> dict : \"\"\" Retrieve all forks, past present and future, of which this node is aware. \"\"\" return self . _query_url ( \"/eth/v1/config/fork_schedule\" )","title":"get_fork_schedule()"},{"location":"config_endpoints/#beacon_client.config_endpoints.ConfigEndpoints.get_node_specification","text":"Retrieve specification configuration used on this node. Source code in beacon_client/config_endpoints.py 8 9 10 11 12 def get_node_specification ( self ) -> dict : \"\"\" Retrieve specification configuration used on this node. \"\"\" return self . _query_url ( \"/eth/v1/config/spec\" )","title":"get_node_specification()"},{"location":"debug_endpoints/","text":"Debug Endpoints Currently unimplemented beacon_client.debug_endpoints.DebugEndpoints Source code in beacon_client/debug_endpoints.py 1 2 class DebugEndpoints : pass","title":"Debug Endpoints"},{"location":"debug_endpoints/#debug-endpoints","text":"","title":"Debug Endpoints"},{"location":"debug_endpoints/#currently-unimplemented","text":"","title":"Currently unimplemented"},{"location":"debug_endpoints/#beacon_client.debug_endpoints.DebugEndpoints","text":"Source code in beacon_client/debug_endpoints.py 1 2 class DebugEndpoints : pass","title":"DebugEndpoints"},{"location":"event_endpoints/","text":"Event Endpoints beacon_client.event_endpoints.EventEndpoints Source code in beacon_client/event_endpoints.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class EventEndpoints : def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events () stream_events ( head = False , block = False , attestation = False , voluntary_exit = False , finalized_checkpoint = False , chain_reorg = False , contribution_and_proof = False ) Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Source code in beacon_client/event_endpoints.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events ()","title":"Event Endpoints"},{"location":"event_endpoints/#event-endpoints","text":"","title":"Event Endpoints"},{"location":"event_endpoints/#beacon_client.event_endpoints.EventEndpoints","text":"Source code in beacon_client/event_endpoints.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class EventEndpoints : def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events ()","title":"EventEndpoints"},{"location":"event_endpoints/#beacon_client.event_endpoints.EventEndpoints.stream_events","text":"Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) Source code in beacon_client/event_endpoints.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def stream_events ( self , head : bool = False , block : bool = False , attestation : bool = False , voluntary_exit : bool = False , finalized_checkpoint : bool = False , chain_reorg : bool = False , contribution_and_proof : bool = False , ): \"\"\" Provides endpoint to subscribe to beacon node Server-Sent-Events stream Returns an Event object with the event name (event.name: str) and the contents (event.data: str) \"\"\" events = [] if head : events . append ( \"head\" ) if block : events . append ( \"block\" ) if attestation : events . append ( \"attestation\" ) if voluntary_exit : events . append ( \"voluntary_exit\" ) if finalized_checkpoint : events . append ( \"finalized_checkpoint\" ) if chain_reorg : events . append ( \"chain_reorg\" ) if contribution_and_proof : events . append ( \"contribution_and_proof\" ) assert len ( events ) > 0 , \"Must select at least one event\" response = self . _query_url ( path = \"/eth/v1/events\" , stream = True , headers = { \"Accept\" : \"text/event-stream\" }, params = { \"topics\" : events }, ) client = SSEClient ( response ) return client . events ()","title":"stream_events()"},{"location":"node_endpoints/","text":"Node Endpoints beacon_client.node_endpoints.NodeEndpoints Source code in beacon_client/node_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class NodeEndpoints : def get_node_identity ( self ): \"\"\" Retrieves data about the node's network presence \"\"\" return self . _query_url ( \"/eth/v1/node/identity\" ) def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ): \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } return self . _query_url ( \"/eth/v1/node/peers\" , params = params ) def get_peer_by_id ( self , peer_id : str ): \"\"\" Retrieves data about the given peer \"\"\" return self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) def get_peer_count ( self ): \"\"\" Retrieves number of known peers. \"\"\" return self . _query_url ( \"/eth/v1/node/peer_count\" ) def get_node_version ( self ): \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" ) def get_syncing_status ( self ): \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" return self . _query_url ( \"/eth/v1/node/syncing\" ) def get_node_health ( self ): \"\"\" Returns node health status in http status codes. Useful for load balancers. \"\"\" return self . _query_url ( \"/eth/v1/node/health\" ) get_node_health () Returns node health status in http status codes. Useful for load balancers. Source code in beacon_client/node_endpoints.py 69 70 71 72 73 def get_node_health ( self ): \"\"\" Returns node health status in http status codes. Useful for load balancers. \"\"\" return self . _query_url ( \"/eth/v1/node/health\" ) get_node_identity () Retrieves data about the node's network presence Source code in beacon_client/node_endpoints.py 2 3 4 5 6 def get_node_identity ( self ): \"\"\" Retrieves data about the node's network presence \"\"\" return self . _query_url ( \"/eth/v1/node/identity\" ) get_node_peers ( disconnected = False , disconnecting = False , connected = False , connecting = False , inbound = False , outbound = False ) Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Source code in beacon_client/node_endpoints.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ): \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } return self . _query_url ( \"/eth/v1/node/peers\" , params = params ) get_node_version () Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. Source code in beacon_client/node_endpoints.py 57 58 59 60 61 def get_node_version ( self ): \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" ) get_peer_by_id ( peer_id ) Retrieves data about the given peer Source code in beacon_client/node_endpoints.py 45 46 47 48 49 def get_peer_by_id ( self , peer_id : str ): \"\"\" Retrieves data about the given peer \"\"\" return self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) get_peer_count () Retrieves number of known peers. Source code in beacon_client/node_endpoints.py 51 52 53 54 55 def get_peer_count ( self ): \"\"\" Retrieves number of known peers. \"\"\" return self . _query_url ( \"/eth/v1/node/peer_count\" ) get_syncing_status () Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. Source code in beacon_client/node_endpoints.py 63 64 65 66 67 def get_syncing_status ( self ): \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" return self . _query_url ( \"/eth/v1/node/syncing\" )","title":"Node Endpoints"},{"location":"node_endpoints/#node-endpoints","text":"","title":"Node Endpoints"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints","text":"Source code in beacon_client/node_endpoints.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class NodeEndpoints : def get_node_identity ( self ): \"\"\" Retrieves data about the node's network presence \"\"\" return self . _query_url ( \"/eth/v1/node/identity\" ) def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ): \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } return self . _query_url ( \"/eth/v1/node/peers\" , params = params ) def get_peer_by_id ( self , peer_id : str ): \"\"\" Retrieves data about the given peer \"\"\" return self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" ) def get_peer_count ( self ): \"\"\" Retrieves number of known peers. \"\"\" return self . _query_url ( \"/eth/v1/node/peer_count\" ) def get_node_version ( self ): \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" ) def get_syncing_status ( self ): \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" return self . _query_url ( \"/eth/v1/node/syncing\" ) def get_node_health ( self ): \"\"\" Returns node health status in http status codes. Useful for load balancers. \"\"\" return self . _query_url ( \"/eth/v1/node/health\" )","title":"NodeEndpoints"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_health","text":"Returns node health status in http status codes. Useful for load balancers. Source code in beacon_client/node_endpoints.py 69 70 71 72 73 def get_node_health ( self ): \"\"\" Returns node health status in http status codes. Useful for load balancers. \"\"\" return self . _query_url ( \"/eth/v1/node/health\" )","title":"get_node_health()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_identity","text":"Retrieves data about the node's network presence Source code in beacon_client/node_endpoints.py 2 3 4 5 6 def get_node_identity ( self ): \"\"\" Retrieves data about the node's network presence \"\"\" return self . _query_url ( \"/eth/v1/node/identity\" )","title":"get_node_identity()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_peers","text":"Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions Source code in beacon_client/node_endpoints.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_node_peers ( self , disconnected : bool = False , disconnecting : bool = False , connected : bool = False , connecting : bool = False , inbound : bool = False , outbound : bool = False , ): \"\"\" Retrieves data about the node's network peers. By default this returns all peers. Multiple query params are combined using AND conditions \"\"\" state = [] direction = [] if disconnected : state . append ( \"disconnected\" ) if disconnecting : state . append ( \"disconnecting\" ) if connected : state . append ( \"connected\" ) if connecting : state . append ( \"connecting\" ) if inbound : direction . append ( \"inbound\" ) if outbound : direction . append ( \"outbound\" ) assert ( len ( state ) > 0 ), \"Must request at least one state in [disconnected, disconnecting, connected, connecting]\" assert ( len ( direction ) > 0 ), \"Must request at least one direction in [inbound, outbound]\" params = { \"state\" : state , \"direction\" : direction } return self . _query_url ( \"/eth/v1/node/peers\" , params = params )","title":"get_node_peers()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_node_version","text":"Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. Source code in beacon_client/node_endpoints.py 57 58 59 60 61 def get_node_version ( self ): \"\"\" Requests that the beacon node identify information about its implementation in a format similar to a HTTP User-Agent field. \"\"\" return self . _query_url ( \"/eth/v1/node/version\" )","title":"get_node_version()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_peer_by_id","text":"Retrieves data about the given peer Source code in beacon_client/node_endpoints.py 45 46 47 48 49 def get_peer_by_id ( self , peer_id : str ): \"\"\" Retrieves data about the given peer \"\"\" return self . _query_url ( f \"/eth/v1/node/peers/ { peer_id } \" )","title":"get_peer_by_id()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_peer_count","text":"Retrieves number of known peers. Source code in beacon_client/node_endpoints.py 51 52 53 54 55 def get_peer_count ( self ): \"\"\" Retrieves number of known peers. \"\"\" return self . _query_url ( \"/eth/v1/node/peer_count\" )","title":"get_peer_count()"},{"location":"node_endpoints/#beacon_client.node_endpoints.NodeEndpoints.get_syncing_status","text":"Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. Source code in beacon_client/node_endpoints.py 63 64 65 66 67 def get_syncing_status ( self ): \"\"\" Requests the beacon node to describe if it's currently syncing or not, and if it is, what block it is up to. \"\"\" return self . _query_url ( \"/eth/v1/node/syncing\" )","title":"get_syncing_status()"},{"location":"validator_endpoints/","text":"Validator Endpoints Currently unimplemented beacon_client.validator_endpoints.ValidatorEndpoints Source code in beacon_client/validator_endpoints.py 1 2 class ValidatorEndpoints : pass","title":"Validator Endpoints"},{"location":"validator_endpoints/#validator-endpoints","text":"","title":"Validator Endpoints"},{"location":"validator_endpoints/#currently-unimplemented","text":"","title":"Currently unimplemented"},{"location":"validator_endpoints/#beacon_client.validator_endpoints.ValidatorEndpoints","text":"Source code in beacon_client/validator_endpoints.py 1 2 class ValidatorEndpoints : pass","title":"ValidatorEndpoints"}]}